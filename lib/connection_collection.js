// Generated by CoffeeScript 1.8.0
(function() {
  var Connection, ConnectionCollection, MultiConnection, Pool, async, inspect, pg, puts, _ref;

  _ref = require("util"), puts = _ref.puts, inspect = _ref.inspect;

  pg = require('pg')["native"];

  async = require('async');

  Pool = require('generic-pool').Pool;

  Connection = require('./connection');

  MultiConnection = require('./multi_connection');

  ConnectionCollection = (function() {
    var defaults;

    defaults = {
      pool_size: 8,
      idle_timeout_millis: 30000
    };

    function ConnectionCollection(config) {
      var node, _base, _i, _len, _ref1;
      this.config = config;
      this.pools = {};
      (_base = this.config).nodes || (_base.nodes = []);
      _ref1 = this.config.nodes;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        node = _ref1[_i];
        this.pools[node.url] = (function(_this) {
          return function(node) {
            var pool;
            pool = new Pool({
              name: 'pg',
              create: function(connected) {
                var client;
                client = new pg.Client(node.url, {
                  ssl: node.ssl
                });
                return client.connect(function(err) {
                  return connected(err, client);
                });
              },
              destroy: function(client) {
                return client.end();
              },
              max: node.pool_size || defaults.pool_size,
              idleTimeoutMillis: node.idle_timeout_millis || defaults.idle_timeout_millis,
              log: false
            });
            pool.url = node.url;
            return pool;
          };
        })(this)(node);
      }
    }

    ConnectionCollection.prototype.connectionFor = function(shardKey) {
      var databaseName, schemaName, shardNumber;
      shardNumber = this._calculateShard(shardKey);
      schemaName = this._schemaOfShard(shardNumber);
      databaseName = this._databaseOfShard(shardNumber);
      return this.connectionForSchema(databaseName, schemaName);
    };

    ConnectionCollection.prototype.connectionForSchema = function(databaseName, schemaName) {
      var pool;
      pool = this._poolFor(databaseName);
      return new Connection(pool, schemaName);
    };

    ConnectionCollection.prototype.connectionForAll = function() {
      var i, max, min, pool, poolsAndShards, schemas, url;
      poolsAndShards = (function() {
        var _i, _len, _ref1, _ref2, _ref3, _results;
        _ref1 = this.config.nodes;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          _ref2 = _ref1[_i], url = _ref2.url, (_ref3 = _ref2.shard, min = _ref3.min, max = _ref3.max);
          pool = this._poolFor(url);
          schemas = (function() {
            var _j, _results1;
            _results1 = [];
            for (i = _j = min; min <= max ? _j <= max : _j >= max; i = min <= max ? ++_j : --_j) {
              _results1.push(this._schemaOfShard(i));
            }
            return _results1;
          }).call(this);
          _results.push([pool, schemas]);
        }
        return _results;
      }).call(this);
      return new MultiConnection(poolsAndShards);
    };

    ConnectionCollection.adminClient = function(opts) {
      return new pg.Client(opts.url, {
        ssl: opts.ssl,
        database: 'postgres'
      });
    };

    ConnectionCollection.prototype.createDatabases = function(done) {
      return async.eachSeries(this.config.nodes, (function(_this) {
        return function(node, nodeDone) {
          var client, databaseName, urlTokens;
          client = new _this.constructor.adminClient(node);
          urlTokens = node.url.split('/');
          databaseName = urlTokens[urlTokens.length - 1];
          return async.series([
            function(stepDone) {
              return client.connect(stepDone);
            }, function(stepDone) {
              return client.query("CREATE DATABASE " + databaseName, stepDone);
            }, function(stepDone) {
              client.end();
              return stepDone();
            }
          ], nodeDone);
        };
      })(this), done);
    };

    ConnectionCollection.prototype.createSchemas = function(done) {
      return async.eachSeries(this.config.nodes, (function(_this) {
        return function(node, nodeDone) {
          var pool, _i, _ref1, _ref2, _results;
          pool = _this._poolFor(node.url);
          return async.eachSeries((function() {
            _results = [];
            for (var _i = _ref1 = node.shard.min, _ref2 = node.shard.max; _ref1 <= _ref2 ? _i <= _ref2 : _i >= _ref2; _ref1 <= _ref2 ? _i++ : _i--){ _results.push(_i); }
            return _results;
          }).apply(this), function(i, schemaDone) {
            var client, result, schema, sqlErr;
            schema = _this._schemaOfShard(i);
            client = result = sqlErr = null;
            return async.series([
              function(done) {
                return pool.acquire(function(err, _client) {
                  client = _client;
                  return done(err);
                });
              }, function(done) {
                return client.query("CREATE SCHEMA " + schema, function(_sqlErr, _result) {
                  result = _result;
                  sqlErr = _sqlErr;
                  return done();
                });
              }, function(done) {
                pool.release(client);
                return done();
              }
            ], function(err) {
              return schemaDone(err || sqlErr, result);
            });
          }, nodeDone);
        };
      })(this), done);
    };

    ConnectionCollection.prototype._poolFor = function(databaseName) {
      return this.pools[databaseName];
    };

    ConnectionCollection.prototype._calculateShard = function(shardKey) {
      var shardNumber;
      shardNumber = ((shardKey - 1) % this.config.shards) + 1;
      if (isNaN(shardNumber)) {
        throw "No shard key provided!";
      }
      return shardNumber;
    };

    ConnectionCollection.prototype._schemaOfShard = function(shardNumber) {
      var zeroPaddedShardNumber;
      zeroPaddedShardNumber = ("0000" + shardNumber).slice(-4);
      return "shard_" + zeroPaddedShardNumber;
    };

    ConnectionCollection.prototype._databaseOfShard = function(shardNumber) {
      var node, _, _ref1;
      _ref1 = this.config.nodes;
      for (_ in _ref1) {
        node = _ref1[_];
        if ((node.shard.min <= shardNumber && shardNumber <= node.shard.max)) {
          return node.url;
        }
      }
    };

    return ConnectionCollection;

  })();

  module.exports = ConnectionCollection;

}).call(this);
